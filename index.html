
<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#4f46e5">
    <title>Tachistoscopio</title>
    
    <!-- Manifest e icone per PWA -->
    <link rel="manifest" href="data:application/json;base64,ewogICJuYW1lIjogIlRhY2hpc3Rvc2NvcGlvIiwKICAic2hvcnRfbmFtZSI6ICJUYWNoaXN0b3Njb3BpbyIsCiAgInN0YXJ0X3VybCI6ICIuIiwKICAiZGlzcGxheSI6ICJzdGFuZGFsb25lIiwKICAiYmFja2dyb3VuZF9jb2xvciI6ICIjZmZmZmZmIiwKICAidGhlbWVfY29sb3IiOiAiIzRmNDZlNSIsCiAgIm9yaWVudGF0aW9uIjogInBvcnRyYWl0LXByaW1hcnkiLAogICJpY29ucyI6IFsKICAgIHsKICAgICAgInNyYyI6ICJodHRwczovL3ZpYS5wbGFjZWhvbGRlci5jb20vMTkyIiwKICAgICAgInNpemVzIjogIjE5MngxOTIiLAogICAgICAidHlwZSI6ICJpbWFnZS9wbmciCiAgICB9LAogICAgewogICAgICAic3JjIjogImh0dHBzOi8vdmlhLnBsYWNlaG9sZGVyLmNvbS81MTIiLAogICAgICAic2l6ZXMiOiAiNTEyeDUxMiIsCiAgICAgICJ0eXBlIjogImltYWdlL3BuZyIKICAgIH0KICBdCn0=">
    <link rel="icon" href="https://via.placeholder.com/48">
    <link rel="apple-touch-icon" href="https://via.placeholder.com/180">
    
    <!-- Tailwind CSS via CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React e ReactDOM via CDN -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel per JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Chart.js per i grafici -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    
    <style>
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
            overflow: hidden;
            position: fixed;
            background-color: #f8fafc;
            -webkit-tap-highlight-color: transparent;
            overscroll-behavior: none;
        }
        #root {
            height: 100%;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }
        input, button, select {
            font-size: 16px; /* Previene lo zoom su iOS */
        }
        /* Per nascondere la barra degli strumenti in modalità standalone */
        @media all and (display-mode: standalone) {
            body {
                padding-top: env(safe-area-inset-top);
                padding-bottom: env(safe-area-inset-bottom);
                padding-left: env(safe-area-inset-left);
                padding-right: env(safe-area-inset-right);
            }
        }
    </style>
</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">
        // Il codice del componente React
        
        const TachistoscopioApp = () => {
          // Stati per gestire l'applicazione
          const [difficulty, setDifficulty] = React.useState('facile');
          const [syllableCount, setSyllableCount] = React.useState(1);
          const [displayTime, setDisplayTime] = React.useState(500); // in millisecondi
          const [isRunning, setIsRunning] = React.useState(false);
          const [currentWord, setCurrentWord] = React.useState('');
          const [placeholder, setPlaceholder] = React.useState('');
          const [userInput, setUserInput] = React.useState('');
          const [score, setScore] = React.useState(0);
          const [totalAttempts, setTotalAttempts] = React.useState(0);
          const [history, setHistory] = React.useState([]);
          const [showAnswer, setShowAnswer] = React.useState(false);
          const [sessionActive, setSessionActive] = React.useState(false);
          const [sessionWords, setSessionWords] = React.useState([]);
          const [currentWordIndex, setCurrentWordIndex] = React.useState(0);
          const [showAddWordModal, setShowAddWordModal] = React.useState(false);
          const [showProgressModal, setShowProgressModal] = React.useState(false);
          const [newWord, setNewWord] = React.useState('');
          const [newWordSyllables, setNewWordSyllables] = React.useState(1);
          const [isFullscreen, setIsFullscreen] = React.useState(false);
          const [sessionReady, setSessionReady] = React.useState(false);
          const [progressHistory, setProgressHistory] = React.useState([]);
          const [readyToShow, setReadyToShow] = React.useState(false);
          const [performanceChartInstance, setPerformanceChartInstance] = React.useState(null);

          // Riferimento al canvas del grafico
          const chartRef = React.useRef(null);

          // Parole italiane organizzate per numero di sillabe (database molto più ampio)
          const [wordsBySyllables, setWordsBySyllables] = React.useState({
            1: ['tu', 'qui', 'sa', 'me', 'te', 'no', 'sì', 'blu', 'giù', 'tre', 'due', 'per', 'chi', 'da', 'al', 'se', 'ma', 'con', 'poi', 'già', 'su', 'giù', 'mai', 'più', 'ciò', 'può', 'mi', 'sa', 'sai', 'so', 'ti', 'lo', 'la', 'ci', 'vi', 'fa', 'tra', 'fra', 'ho', 'ha', 'dei', 're', 'dei', 'va', 'fu', 'né', 'ed', 'ad', 'un', 'vi', 'là', 'su', 'vo', 'mo', 'do', 'si'],
            
            2: ['casa', 'sole', 'vino', 'mare', 'pane', 'mela', 'cane', 'gatto', 'libro', 'sedia', 'testa', 'piede', 'mano', 'luce', 'nero', 'rosso', 'verde', 'moto', 'lento', 'bello', 'terra', 'vita', 'uomo', 'donna', 'notte', 'giorno', 'occhi', 'bocca', 'naso', 'cuore', 'sangue', 'mente', 'fiume', 'lago', 'monte', 'cielo', 'auto', 'treno', 'nave', 'carta', 'penna', 'porta', 'muro', 'rete', 'voce', 'fame', 'sete', 'sonno', 'mese', 'anno', 'ora', 'oggi', 'ieri', 'torta', 'pasta', 'cibo', 'bici', 'radio', 'caffè', 'pasto', 'luna', 'fiore', 'bosco', 'stella', 'piuma', 'piano', 'forte', 'lungo', 'corto', 'nuovo', 'alto', 'basso', 'chiaro', 'scuro', 'primo', 'dopo', 'molto', 'poco', 'tanto', 'mille', 'cento', 'mese', 'fuoco', 'ghiaccio', 'acqua', 'vento', 'caldo', 'freddo', 'fuori', 'dentro', 'prima', 'vero', 'falso', 'strano', 'giusto', 'vivo', 'morto', 'dolce', 'amaro', 'salato', 'acido'],
            
            3: ['tavolo', 'pagina', 'finestra', 'balcone', 'lamiera', 'corrente', 'farmacia', 'bottega', 'mattino', 'nuvola', 'pensare', 'cadere', 'vicino', 'parola', 'tecnico', 'metodo', 'leggere', 'scrivere', 'parlare', 'ascoltare', 'guardare', 'toccare', 'sentire', 'orecchio', 'ospedale', 'bambino', 'famiglia', 'telefono', 'computer', 'cammino', 'viaggio', 'aereo', 'animale', 'colore', 'numero', 'settimana', 'momento', 'domani', 'persona', 'popolo', 'città', 'villaggio', 'regione', 'nazione', 'memoria', 'cervello', 'muscolo', 'stomaco', 'organo', 'costume', 'vestito', 'cappello', 'camicia', 'pantaloni', 'giacca', 'scarpe', 'calzini', 'maglione', 'giardino', 'albero', 'cortile', 'piscina', 'spiaggia', 'montagna', 'deserto', 'foresta', 'collina', 'altopiano', 'galleria', 'strada', 'piazza', 'negozio', 'supermercato', 'ristorante', 'albergo', 'cinema', 'teatro', 'palazzo', 'stazione', 'macchina', 'autobus', 'campagna', 'silenzio', 'rumore', 'musica', 'canzone', 'batteria', 'chitarra', 'violino', 'pianoforte', 'orchestra', 'concerto', 'attore', 'attrice', 'cantante', 'politica', 'mercato', 'capitale', 'azienda', 'lavoro', 'ufficio', 'scuola', 'università'],
            
            4: ['bicicletta', 'automobile', 'televisione', 'meccanico', 'ristorante', 'biblioteca', 'geografia', 'matematica', 'università', 'abilità', 'occupazione', 'animazione', 'decorazione', 'divertimento', 'preferenza', 'agricoltura', 'informazione', 'conoscenza', 'tecnologia', 'elettricità', 'emozione', 'sensazione', 'esperienza', 'matematico', 'geologo', 'architetto', 'ingegnere', 'disegnatore', 'scienziato', 'informatico', 'statistico', 'economista', 'politologo', 'sociologo', 'psicologo', 'filosofo', 'religione', 'cattolico', 'protestante', 'ortodosso', 'musulmano', 'buddista', 'induista', 'spiritualità', 'meditazione', 'preghiera', 'superstizione', 'tradizione', 'modernità', 'innovazione', 'evoluzione', 'rivoluzione', 'popolazione', 'democrazia', 'aristocrazia', 'monarchia', 'dittatura', 'repubblica', 'parlamento', 'presidente', 'governatore', 'ministero', 'segretario', 'ambasciata', 'diplomazia', 'burocrazia', 'amministrare', 'governare', 'legislazione', 'costituzione', 'protezione', 'sicurezza', 'militare', 'poliziotto', 'avvocato', 'giudice', 'tribunale', 'medicina', 'chirurgia', 'farmacia', 'ospedale', 'ambulanza', 'emergenza', 'matematica', 'geometria', 'aritmetica', 'trigonometria', 'calcolatrice', 'geografia', 'continente', 'oceano', 'montagna', 'vulcano', 'terremoto', 'atmosfera', 'temperatura', 'barometro', 'termometro'],
            
            5: ['collaborazione', 'responsabilità', 'comunicazione', 'determinazione', 'illuminazione', 'accelerazione', 'protagonista', 'educazione', 'argomentazione', 'alimentazione', 'apprendimento', 'comprensione', 'coordinazione', 'immaginazione', 'interpretazione', 'interrogazione', 'memorizzazione', 'realizzazione', 'rappresentazione', 'rivoluzionario', 'trasformazione', 'conservazione', 'pianificazione', 'manifestazione', 'dichiarazione', 'considerazione', 'complicazione', 'semplificazione', 'concentrazione', 'determinazione', 'partecipazione', 'informazione', 'digitalizzazione', 'materializzazione', 'sperimentazione', 'investigazione', 'sopravvivenza', 'adattamento', 'giustificazione', 'autorizzazione', 'specializzazione', 'raccomandazione', 'classificazione', 'organizzazione', 'generalizzazione', 'regolamentazione', 'riconoscimento', 'caratterizzazione', 'interpretazione', 'amministrazione', 'generalizzazione', 'partecipazione', 'personalizzazione', 'matematicamente', 'geograficamente', 'biologicamente', 'scientificamente', 'filosoficamente', 'politicamente', 'economicamente', 'sociologicamente', 'psicologicamente', 'linguisticamente', 'tradizionalmente', 'culturalmente', 'professionalmente', 'progressivamente', 'personalmente', 'individualmente', 'collettivamente', 'democraticamente', 'apparentemente', 'effettivamente', 'attualmente', 'generalmente', 'particolarmente', 'relativamente', 'conseguentemente', 'frequentemente', 'occasionalmente', 'involontariamente', 'automaticamente', 'essenzialmente', 'universalmente', 'teoricamente', 'letteralmente', 'virtualmente', 'ipoteticamente', 'metaforicamente', 'precisamente', 'approssimativamente', 'sufficientemente', 'necessariamente', 'volontariamente', 'indirettamente', 'sistematicamente'],
            
            6: ['rappresentazione', 'interdisciplinare', 'internazionale', 'audiovisivo', 'meteorologia', 'individualità', 'universitario', 'multiculturale', 'identificazione', 'democratizzazione', 'compatibilità', 'straordinarietà', 'mediterraneità', 'anticostituzionale', 'professionalità', 'costituzionalità', 'antirivoluzionario', 'cinematografico', 'epistemologicamente', 'indeterminatezza', 'radiologicamente', 'industrializzazione', 'internazionalizzazione', 'decentralizzazione', 'multiprofessionalità', 'interdipendenza', 'autoreferenzialità', 'biodegradabilità', 'controrivoluzionario', 'elettromagnetico', 'fotosensibilità', 'istituzionalizzazione', 'multidimensionalità', 'neocapitalistico', 'onnicomprensivo', 'pluridisciplinarietà', 'rappresentatività', 'sovradimensionamento', 'territorialità', 'unidirezionalità', 'videoconferenza', 'zoologicamente', 'anatomopatologico', 'bidimensionalità', 'cronologicamente', 'deterritorializzazione', 'enciclopedismo', 'fenomenologicamente', 'geolocalizzazione', 'idroelettricità', 'immaterialità']
          });

          // Configurazione delle difficoltà
          const difficultySettings = {
            facile: { minSyllables: 1, maxSyllables: 2, minTime: 500, maxTime: 5000 },
            medio: { minSyllables: 2, maxSyllables: 4, minTime: 300, maxTime: 5000 },
            difficile: { minSyllables: 3, maxSyllables: 6, minTime: 100, maxTime: 5000 }
          };

          // Verifica se il browser supporta la modalità fullscreen
          const supportsFullscreen = document.documentElement.requestFullscreen || 
                                     document.documentElement.webkitRequestFullscreen || 
                                     document.documentElement.mozRequestFullScreen ||
                                     document.documentElement.msRequestFullscreen;

          // Controlla cambiamenti nello stato di fullscreen
          React.useEffect(() => {
            const handleFullscreenChange = () => {
              setIsFullscreen(!!document.fullscreenElement);
            };
            
            document.addEventListener('fullscreenchange', handleFullscreenChange);
            document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
            document.addEventListener('mozfullscreenchange', handleFullscreenChange);
            document.addEventListener('MSFullscreenChange', handleFullscreenChange);
            
            return () => {
              document.removeEventListener('fullscreenchange', handleFullscreenChange);
              document.removeEventListener('webkitfullscreenchange', handleFullscreenChange);
              document.removeEventListener('mozfullscreenchange', handleFullscreenChange);
              document.removeEventListener('MSFullscreenChange', handleFullscreenChange);
            };
          }, []);

          // Aggiorna le impostazioni in base alla difficoltà selezionata
          React.useEffect(() => {
            const settings = difficultySettings[difficulty];
            setSyllableCount(prev => Math.min(Math.max(prev, settings.minSyllables), settings.maxSyllables));
            setDisplayTime(prev => Math.min(Math.max(prev, settings.minTime), settings.maxTime));
          }, [difficulty]);

          // Carica le parole dal localStorage all'avvio
          React.useEffect(() => {
            const savedWords = localStorage.getItem('tachistoscopio_words');
            if (savedWords) {
              try {
                const parsed = JSON.parse(savedWords);
                if (parsed && typeof parsed === 'object') {
                  setWordsBySyllables(parsed);
                }
              } catch (e) {
                console.error("Errore nel caricamento delle parole salvate:", e);
              }
            }
            
            // Carica la cronologia dei progressi
            const savedProgress = localStorage.getItem('tachistoscopio_progress');
            if (savedProgress) {
              try {
                const parsed = JSON.parse(savedProgress);
                if (Array.isArray(parsed)) {
                  setProgressHistory(parsed);
                }
              } catch (e) {
                console.error("Errore nel caricamento dei progressi salvati:", e);
              }
            }
          }, []);

          // Aggiorna il grafico quando viene visualizzato il modal dei progressi
          React.useEffect(() => {
            if (showProgressModal && progressHistory.length > 0) {
              updatePerformanceChart();
            }
          }, [showProgressModal]);
          
          // Calcola il punteggio di performance basato su sillabe, tempo e percentuale di successo
          const calculatePerformanceScore = (session) => {
            // Fattore sillabe: più sillabe = punteggio più alto
            const syllableFactor = session.syllables * 10;
            
            // Fattore tempo: meno tempo = punteggio più alto (inverso)
            // Normalizziamo rispetto a 5000ms (max possibile)
            const timeFactor = (1 - (session.displayTime / 5000)) * 50;
            
            // Fattore accuratezza: percentuale corretta
            const accuracyFactor = session.percentage;
            
            // Combiniamo i fattori per un punteggio totale
            // La formula dà più peso all'accuratezza, poi alle sillabe e infine al tempo
            return (syllableFactor + timeFactor) * (accuracyFactor / 100);
          };

          // Aggiorna il grafico delle performance
          const updatePerformanceChart = () => {
            if (!chartRef.current || progressHistory.length === 0) return;
            
            // Ordina la cronologia per data
            const sortedHistory = [...progressHistory].sort((a, b) => new Date(a.date) - new Date(b.date));
            
            // Prepara i dati per il grafico
            const labels = sortedHistory.map((session, index) => `Sess. ${index + 1}`);
            const accuracyData = sortedHistory.map(session => session.percentage);
            const performanceData = sortedHistory.map(session => calculatePerformanceScore(session));
            
            // Formatta le date
            const dates = sortedHistory.map(session => {
              const date = new Date(session.date);
              return `${date.getDate()}/${date.getMonth() + 1}/${date.getFullYear()}`;
            });
            
            // Crea o aggiorna il grafico
            if (performanceChartInstance) {
              performanceChartInstance.destroy();
            }
            
            const ctx = chartRef.current.getContext('2d');
            const newChart = new Chart(ctx, {
              type: 'line',
              data: {
                labels: labels,
                datasets: [
                  {
                    label: 'Percentuale Corretta (%)',
                    data: accuracyData,
                    borderColor: 'rgba(75, 192, 192, 1)',
                    backgroundColor: 'rgba(75, 192, 192, 0.2)',
                    tension: 0.3,
                    yAxisID: 'y'
                  },
                  {
                    label: 'Punteggio Performance',
                    data: performanceData,
                    borderColor: 'rgba(153, 102, 255, 1)',
                    backgroundColor: 'rgba(153, 102, 255, 0.2)',
                    tension: 0.3,
                    yAxisID: 'y1'
                  }
                ]
              },
              options: {
                responsive: true,
                interaction: {
                  mode: 'index',
                  intersect: false
                },
                stacked: false,
                scales: {
                  y: {
                    type: 'linear',
                    display: true,
                    position: 'left',
                    title: {
                      display: true,
                      text: 'Percentuale (%)',
                      color: 'rgba(75, 192, 192, 1)'
                    },
                    min: 0,
                    max: 100
                  },
                  y1: {
                    type: 'linear',
                    display: true,
                    position: 'right',
                    title: {
                      display: true,
                      text: 'Punteggio',
                      color: 'rgba(153, 102, 255, 1)'
                    },
                    min: 0,
                    grid: {
                      drawOnChartArea: false
                    }
                  }
                },
                plugins: {
                  tooltip: {
                    callbacks: {
                      afterTitle: function(context) {
                        const index = context[0].dataIndex;
                        return dates[index];
                      },
                      afterBody: function(context) {
                        const index = context[0].dataIndex;
                        const session = sortedHistory[index];
                        return [
                          `Sillabe: ${session.syllables}`,
                          `Tempo: ${session.displayTime}ms`,
                          `Punteggio: ${session.score}/${session.totalAttempts}`
                        ];
                      }
                    }
                  }
                }
              }
            });
            
            setPerformanceChartInstance(newChart);
          };

          // Seleziona parole per la sessione e imposta immediatamente la prima parola
          const selectSessionWords = () => {
            const availableWords = wordsBySyllables[syllableCount] || [];
            if (availableWords.length === 0) {
              alert('Nessuna parola disponibile per questo numero di sillabe');
              return false;
            }
            
            // Seleziona 10 parole casuali (o meno se non ce ne sono abbastanza)
            const wordCount = Math.min(10, availableWords.length);
            const selectedWords = [];
            const indices = new Set();
            
            while (indices.size < wordCount) {
              const idx = Math.floor(Math.random() * availableWords.length);
              if (!indices.has(idx)) {
                indices.add(idx);
                selectedWords.push(availableWords[idx]);
              }
            }
            
            return selectedWords;
          };

          // Avvia una nuova sessione di esercizio
          const startSession = () => {
            // Resetta completamente lo stato prima di iniziare una nuova sessione
            setShowAnswer(false);
            setIsRunning(false);
            setUserInput('');
            setScore(0);
            setTotalAttempts(0);
            setHistory([]);
            setCurrentWordIndex(0);
            setPlaceholder('');
            
            // Seleziona e imposta le parole prima di rendere la sessione attiva
            const words = selectSessionWords();
            if (words && words.length > 0) {
              // Prima imposta la parola corrente e le parole della sessione
              setSessionWords(words);
              setCurrentWord(words[0]);
              
              // Poi attiva la sessione e prepara per mostrare la prima parola
              setSessionActive(true);
              setReadyToShow(true);
            }
          };

          // Prepara per mostrare la prossima parola
          const prepareNextWord = () => {
            if (currentWordIndex >= sessionWords.length) {
              endSession();
              return;
            }
            
            setCurrentWord(sessionWords[currentWordIndex]);
            setUserInput('');
            setShowAnswer(false);
            setReadyToShow(true);
            setIsRunning(false);
            setPlaceholder('');
          };

          // Crea una stringa di # della stessa lunghezza della parola
          const createPlaceholder = (word) => {
            return '#'.repeat(word.length);
          };

          // Mostra la parola corrente
          const showCurrentWord = () => {
            setIsRunning(true);
            setReadyToShow(false);
            setUserInput('');
            
            // Mostra la parola per il tempo impostato, poi la sostituisce con #
            setTimeout(() => {
              setIsRunning(false);
              const placeholderText = createPlaceholder(currentWord);
              setPlaceholder(placeholderText);
            }, displayTime);
          };

          // Verifica la risposta dell'utente
          const checkAnswer = () => {
            // Incrementa il contatore dei tentativi prima di verificare la risposta
            const newTotalAttempts = totalAttempts + 1;
            setTotalAttempts(newTotalAttempts);
            
            // Verifica se la risposta è corretta
            const correct = userInput.toLowerCase().trim() === currentWord.toLowerCase();
            
            // Aggiorna il punteggio se la risposta è corretta
            const newScore = correct ? score + 1 : score;
            setScore(newScore);
            
            // Aggiorna la cronologia
            const newHistory = [...history, {
              word: currentWord,
              input: userInput,
              correct: correct
            }];
            setHistory(newHistory);
            
            // Mostra la risposta corretta
            setShowAnswer(true);
            
            // Passa alla prossima parola dopo un breve ritardo
            setTimeout(() => {
              const nextIndex = currentWordIndex + 1;
              setCurrentWordIndex(nextIndex);
              
              if (nextIndex < sessionWords.length) {
                // Imposta già la prossima parola
                setCurrentWord(sessionWords[nextIndex]);
                setReadyToShow(true);
                setShowAnswer(false);
                setPlaceholder('');
                setUserInput('');
              } else {
                // Salva i progressi e termina la sessione
                const percentageScore = newTotalAttempts > 0 
                  ? Math.round((newScore / newTotalAttempts) * 100) 
                  : 0;
                
                const newSession = {
                  date: new Date().toISOString(),
                  difficulty,
                  syllables: syllableCount,
                  displayTime,
                  score: newScore,
                  totalAttempts: newTotalAttempts,
                  percentage: percentageScore
                };
                
                const updatedProgress = [...progressHistory, newSession];
                setProgressHistory(updatedProgress);
                
                // Salva nel localStorage
                try {
                  localStorage.setItem('tachistoscopio_progress', JSON.stringify(updatedProgress));
                } catch (e) {
                  console.error("Errore nel salvataggio dei progressi:", e);
                }
                
                setSessionActive(false);
                setReadyToShow(false);
                setUserInput('');
                
                // Messaggio di fine sessione
                alert(`Sessione completata!\nPunteggio: ${newScore}/${newTotalAttempts}\nPercentuale: ${percentageScore}%`);
              }
            }, 1500);
          };

          // Termina la sessione
          const endSession = () => {
            const percentageScore = totalAttempts > 0 ? Math.round((score / totalAttempts) * 100) : 0;
            
            // Salva i progressi
            const newSession = {
              date: new Date().toISOString(),
              difficulty,
              syllables: syllableCount,
              displayTime,
              score,
              totalAttempts,
              percentage: percentageScore
            };
            
            const updatedProgress = [...progressHistory, newSession];
            setProgressHistory(updatedProgress);
            
            // Salva nel localStorage
            try {
              localStorage.setItem('tachistoscopio_progress', JSON.stringify(updatedProgress));
            } catch (e) {
              console.error("Errore nel salvataggio dei progressi:", e);
            }
            
            // Resetta completamente lo stato
            setSessionActive(false);
            setShowAnswer(false);
            setReadyToShow(false);
            setIsRunning(false);
            setUserInput('');
            setCurrentWord('');
            setPlaceholder('');
            
            alert(`Sessione completata!\nPunteggio: ${score}/${totalAttempts}\nPercentuale: ${percentageScore}%`);
          };

          // Funzione per aggiungere una nuova parola
          const addNewWord = () => {
            if (newWord.trim() === '') {
              alert('Per favore, inserisci una parola');
              return;
            }

            // Aggiungi la parola al numero di sillabe selezionato
            setWordsBySyllables(prev => {
              const updatedWords = { ...prev };
              if (!updatedWords[newWordSyllables]) {
                updatedWords[newWordSyllables] = [];
              }
              updatedWords[newWordSyllables] = [...updatedWords[newWordSyllables], newWord.trim().toLowerCase()];
              
              // Salva nel localStorage
              try {
                localStorage.setItem('tachistoscopio_words', JSON.stringify(updatedWords));
              } catch (e) {
                console.error("Errore nel salvataggio delle parole:", e);
              }
              
              return updatedWords;
            });

            // Resetta i campi e chiudi il modal
            setNewWord('');
            setShowAddWordModal(false);
            alert(`Parola "${newWord}" aggiunta con successo al gruppo di ${newWordSyllables} sillabe!`);
          };

          // Cancella i dati dei progressi
          const clearProgressData = () => {
            if (confirm("Sei sicuro di voler cancellare tutta la cronologia dei progressi?")) {
              setProgressHistory([]);
              localStorage.removeItem('tachistoscopio_progress');
              
              // Distruggi il grafico se esiste
              if (performanceChartInstance) {
                performanceChartInstance.destroy();
                setPerformanceChartInstance(null);
              }
              
              alert('Dati dei progressi cancellati con successo!');
            }
          };

          // Esporta le parole in formato JSON
          const exportWords = () => {
            try {
              const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(wordsBySyllables));
              const downloadAnchorNode = document.createElement('a');
              downloadAnchorNode.setAttribute("href", dataStr);
              downloadAnchorNode.setAttribute("download", "tachistoscopio_parole.json");
              document.body.appendChild(downloadAnchorNode);
              downloadAnchorNode.click();
              downloadAnchorNode.remove();
            } catch (e) {
              alert("Errore nell'esportazione delle parole: " + e.message);
            }
          };

          // Importa le parole da un file JSON
          const importWords = (event) => {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
              try {
                const importedWords = JSON.parse(e.target.result);
                if (importedWords && typeof importedWords === 'object') {
                  setWordsBySyllables(importedWords);
                  
                  // Salva nel localStorage
                  localStorage.setItem('tachistoscopio_words', JSON.stringify(importedWords));
                  
                  alert('Parole importate con successo!');
                } else {
                  throw new Error("Formato file non valido");
                }
              } catch (error) {
                alert('Errore durante l\'importazione: ' + error.message);
              }
            };
            reader.readAsText(file);
          };

          // Abilita/disabilita la modalità a schermo intero
          const toggleFullscreen = () => {
            if (!document.fullscreenElement) {
              const docEl = document.documentElement;
              
              const requestFullScreen = docEl.requestFullscreen || 
                                        docEl.webkitRequestFullscreen || 
                                        docEl.mozRequestFullScreen || 
                                        docEl.msRequestFullscreen;
                
              if (requestFullScreen) {
                requestFullScreen.call(docEl).catch(err => {
                  console.error(`Errore nella modalità a schermo intero: ${err.message}`);
                });
              }
            } else {
              const exitFullscreen = document.exitFullscreen || 
                                     document.webkitExitFullscreen || 
                                     document.mozCancelFullScreen || 
                                     document.msExitFullscreen;
                                     
              if (exitFullscreen) {
                exitFullscreen.call(document);
              }
            }
          };

          // Formatta la data in modo leggibile
          const formatDate = (isoString) => {
            try {
              const date = new Date(isoString);
              return date.toLocaleDateString() + ' ' + date.toLocaleTimeString();
            } catch (e) {
              return isoString;
            }
          };

          return (
            <div className="p-4 max-w-lg mx-auto bg-white rounded-lg shadow-lg h-full overflow-auto">
              <div className="flex justify-between items-center mb-4">
                <h1 className="text-xl font-bold">Lettura Tachistoscopica</h1>
                <div className="flex gap-2">
                  <button 
                    className="bg-purple-500 text-white p-2 rounded-full"
                    onClick={() => setShowProgressModal(true)}
                    aria-label="Mostra progressi"
                  >
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                      <path d="M21 12c0 1.66-4 3-9 3s-9-1.34-9-3"></path>
                      <path d="M3 5v14c0 1.66 4 3 9 3s9-1.34 9-3V5"></path>
                      <path d="M3 12c0 1.66 4 3 9 3s9-1.34 9-3"></path>
                      <path d="M3 5c0 1.66 4 3 9 3s9-1.34 9-3"></path>
                    </svg>
                  </button>
                  {supportsFullscreen && (
                    <button 
                      className="bg-blue-500 text-white p-2 rounded-full"
                      onClick={toggleFullscreen}
                      aria-label={isFullscreen ? "Esci da schermo intero" : "Schermo intero"}
                    >
                      {isFullscreen ? (
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                          <path d="M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3"></path>
                        </svg>
                      ) : (
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                          <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"></path>
                        </svg>
                      )}
                    </button>
                  )}
                </div>
              </div>
              
              {!sessionActive ? (
                <div className="setup-panel space-y-4">
                  <div className="mb-4">
                    <label className="block text-gray-700 mb-2">Livello di difficoltà:</label>
                    <select 
                      className="w-full p-2 border rounded"
                      value={difficulty}
                      onChange={(e) => setDifficulty(e.target.value)}
                    >
                      <option value="facile">Facile</option>
                      <option value="medio">Medio</option>
                      <option value="difficile">Difficile</option>
                    </select>
                  </div>
                  
                  <div className="mb-4">
                    <label className="block text-gray-700 mb-2">Numero di sillabe:</label>
                    <input 
                      type="range" 
                      min={difficultySettings[difficulty].minSyllables} 
                      max={difficultySettings[difficulty].maxSyllables}
                      value={syllableCount}
                      onChange={(e) => setSyllableCount(parseInt(e.target.value))}
                      className="w-full"
                    />
                    <div className="flex justify-between">
                      <span>{difficultySettings[difficulty].minSyllables}</span>
                      <span>{syllableCount}</span>
                      <span>{difficultySettings[difficulty].maxSyllables}</span>
                    </div>
                  </div>
                  
                  <div className="mb-4">
                    <label className="block text-gray-700 mb-2">Tempo di visualizzazione (ms):</label>
                    <input 
                      type="range" 
                      min={difficultySettings[difficulty].minTime} 
                      max={difficultySettings[difficulty].maxTime}
                      value={displayTime}
                      onChange={(e) => setDisplayTime(parseInt(e.target.value))}
                      className="w-full"
                    />
                    <div className="flex justify-between">
                      <span>{difficultySettings[difficulty].minTime}</span>
                      <span>{displayTime}</span>
                      <span>{difficultySettings[difficulty].maxTime}</span>
                    </div>
                  </div>
                  
                  <div className="flex flex-col sm:flex-row gap-2 mb-4">
                    <button 
                      className="flex-1 bg-blue-500 text-white py-2 px-4 rounded hover:bg-blue-600 transition text-sm"
                      onClick={startSession}
                    >
                      Inizia Esercizio
                    </button>
                    <button 
                      className="flex-1 bg-green-500 text-white py-2 px-4 rounded hover:bg-green-600 transition text-sm"
                      onClick={() => setShowAddWordModal(true)}
                    >
                      Aggiungi Parole
                    </button>
                  </div>
                  
                  <div className="flex flex-col sm:flex-row gap-2">
                    <button 
                      className="flex-1 bg-purple-500 text-white py-2 px-4 rounded hover:bg-purple-600 transition text-sm"
                      onClick={exportWords}
                    >
                      Esporta Parole
                    </button>
                    <label className="flex-1 bg-orange-500 text-white py-2 px-4 rounded hover:bg-orange-600 transition text-center cursor-pointer text-sm">
                      Importa Parole
                      <input 
                        type="file" 
                        accept=".json" 
                        className="hidden" 
                        onChange={importWords}
                      />
                    </label>
                  </div>
                  
                  <div className="mt-4">
                    <h3 className="font-bold mb-2">Parole disponibili per {syllableCount} sillabe:</h3>
                    <div className="border rounded p-2 max-h-24 overflow-y-auto">
                      {wordsBySyllables[syllableCount] && wordsBySyllables[syllableCount].length > 0 ? (
                        <p>{wordsBySyllables[syllableCount].join(', ')}</p>
                      ) : (
                        <p className="text-gray-500">Nessuna parola disponibile per questo numero di sillabe</p>
                      )}
                    </div>
                  </div>
                </div>
              ) : (
                <div className="exercise-panel">
                  <div className="mb-6">
                    <div className="flex justify-between mb-2">
                      <span>Parola: {currentWordIndex + 1}/{sessionWords.length}</span>
                      <span>Punteggio: {score}/{totalAttempts}</span>
                    </div>
                    
                    <div className="h-32 flex items-center justify-center border rounded mb-4">
                      {isRunning ? (
                        <div className="text-3xl font-bold">{currentWord}</div>
                      ) : showAnswer ? (
                        <div className="text-xl">
                          <span className="font-bold">Parola: </span>
                          <span className="text-blue-600">{currentWord}</span>
                          <br />
                          <span className="font-bold">La tua risposta: </span>
                          <span className={history[history.length-1]?.correct ? "text-green-600" : "text-red-600"}>
                            {userInput}
                          </span>
                        </div>
                      ) : readyToShow ? (
                        <button 
                          className="bg-blue-500 text-white py-3 px-6 rounded-full hover:bg-blue-600 transition text-lg"
                          onClick={showCurrentWord}
                        >
                          Mostra Parola
                        </button>
                      ) : (
                        <div className="text-3xl font-bold text-gray-500">
                          {placeholder}
                        </div>
                      )}
                    </div>
                    
                    {!isRunning && !showAnswer && !readyToShow && (
                      <div className="mb-4">
                        <label className="block text-gray-700 mb-2">Cosa hai visto?</label>
                        <div className="flex">
                          <input 
                            type="text" 
                            className="flex-grow p-2 border rounded-l"
                            value={userInput}
                            onChange={(e) => setUserInput(e.target.value)}
                            onKeyDown={(e) => e.key === 'Enter' && checkAnswer()}
                            autoFocus
                          />
                          <button 
                            className="bg-green-500 text-white py-2 px-4 rounded-r hover:bg-green-600 transition"
                            onClick={checkAnswer}
                          >
                            Controlla
                          </button>
                        </div>
                      </div>
                    )}
                    
                    <div className="mt-4">
                      <h3 className="font-bold mb-2">Storico:</h3>
                      <div className="max-h-32 overflow-y-auto border rounded p-2">
                        {history.map((item, index) => (
                          <div key={index} className={`${item.correct ? "text-green-600" : "text-red-600"} mb-1`}>
                            Parola: <span className="font-medium">{item.word}</span> - 
                            Risposta: <span className="font-medium">{item.input}</span>
                          </div>
                        ))}
                        {history.length === 0 && (
                          <div className="text-gray-500">Nessun tentativo ancora registrato</div>
                        )}
                      </div>
                    </div>
                    
                    <button 
                      className="w-full mt-4 bg-red-500 text-white py-2 px-4 rounded hover:bg-red-600 transition"
                      onClick={endSession}
                    >
                      Termina Sessione
                    </button>
                  </div>
                </div>
              )}
              
              <div className="mt-4 pt-4 border-t text-sm text-gray-600">
                <p><strong>Istruzioni:</strong> Questo programma ti aiuterà a migliorare la tua capacità di lettura rapida. Seleziona il livello di difficoltà, il numero di sillabe e il tempo di visualizzazione, quindi inizia l'esercizio.</p>
                <p className="mt-2"><strong>Modalità a schermo intero:</strong> Usa il pulsante in alto a destra per entrare in modalità a schermo intero e avere un'esperienza ottimale senza distrazioni.</p>
              </div>
              
              {/* Modal per aggiungere nuove parole */}
              {showAddWordModal && (
                <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
                  <div className="bg-white rounded-lg p-6 max-w-sm w-full">
                    <h3 className="text-xl font-bold mb-4">Aggiungi Nuova Parola</h3>
                    
                    <div className="mb-4">
                      <label className="block text-gray-700 mb-2">Parola:</label>
                      <input 
                        type="text" 
                        className="w-full p-2 border rounded"
                        value={newWord}
                        onChange={(e) => setNewWord(e.target.value)}
                        placeholder="Inserisci una parola"
                      />
                    </div>
                    
                    <div className="mb-4">
                      <label className="block text-gray-700 mb-2">Numero di sillabe:</label>
                      <input 
                        type="number" 
                        min="1" 
                        max="10"
                        className="w-full p-2 border rounded"
                        value={newWordSyllables}
                        onChange={(e) => setNewWordSyllables(parseInt(e.target.value))}
                      />
                    </div>
                    
                    <div className="flex justify-end space-x-2">
                      <button 
                        className="bg-gray-300 text-gray-800 py-2 px-4 rounded hover:bg-gray-400 transition"
                        onClick={() => setShowAddWordModal(false)}
                      >
                        Annulla
                      </button>
                      <button 
                        className="bg-green-500 text-white py-2 px-4 rounded hover:bg-green-600 transition"
                        onClick={addNewWord}
                      >
                        Aggiungi
                      </button>
                    </div>
                  </div>
                </div>
              )}
              
              {/* Modal per visualizzare i progressi */}
              {showProgressModal && (
                <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
                  <div className="bg-white rounded-lg p-6 max-w-4xl w-full h-4/5 flex flex-col">
                    <h3 className="text-xl font-bold mb-4">Cronologia Progressi</h3>
                    
                    {/* Grafico delle performance */}
                    <div className="mb-6 h-64 border rounded p-2">
                      {progressHistory.length > 0 ? (
                        <canvas ref={chartRef}></canvas>
                      ) : (
                        <div className="h-full flex items-center justify-center text-gray-500">
                          Nessun dato di progresso disponibile per la visualizzazione del grafico.
                        </div>
                      )}
                    </div>
                    
                    <h4 className="font-bold mb-2">Dettaglio Sessioni</h4>
                    <div className="overflow-y-auto flex-grow mb-4">
                      {progressHistory.length > 0 ? (
                        <div className="overflow-x-auto">
                          <table className="min-w-full border-collapse border border-gray-300">
                            <thead>
                              <tr className="bg-gray-100">
                                <th className="border border-gray-300 px-4 py-2">Data</th>
                                <th className="border border-gray-300 px-4 py-2">Difficoltà</th>
                                <th className="border border-gray-300 px-4 py-2">Sillabe</th>
                                <th className="border border-gray-300 px-4 py-2">Tempo (ms)</th>
                                <th className="border border-gray-300 px-4 py-2">Punteggio</th>
                                <th className="border border-gray-300 px-4 py-2">Tentativi</th>
                                <th className="border border-gray-300 px-4 py-2">Percentuale</th>
                                <th className="border border-gray-300 px-4 py-2">Performance</th>
                              </tr>
                            </thead>
                            <tbody>
                              {progressHistory.map((session, index) => (
                                <tr key={index} className={index % 2 === 0 ? "bg-white" : "bg-gray-50"}>
                                  <td className="border border-gray-300 px-4 py-2">{formatDate(session.date)}</td>
                                  <td className="border border-gray-300 px-4 py-2">{session.difficulty}</td>
                                  <td className="border border-gray-300 px-4 py-2">{session.syllables}</td>
                                  <td className="border border-gray-300 px-4 py-2">{session.displayTime}</td>
                                  <td className="border border-gray-300 px-4 py-2">{session.score}</td>
                                  <td className="border border-gray-300 px-4 py-2">{session.totalAttempts}</td>
                                  <td className="border border-gray-300 px-4 py-2">{session.percentage}%</td>
                                  <td className="border border-gray-300 px-4 py-2 text-right font-semibold">
                                    {calculatePerformanceScore(session).toFixed(1)}
                                  </td>
                                </tr>
                              ))}
                            </tbody>
                          </table>
                        </div>
                      ) : (
                        <div className="text-center py-8 text-gray-500">
                          Nessun dato di progresso disponibile. Completa una sessione per vedere i risultati qui.
                        </div>
                      )}
                    </div>
                    
                    <div className="flex justify-between">
                      <button 
                        className="bg-red-500 text-white py-2 px-4 rounded hover:bg-red-600 transition"
                        onClick={clearProgressData}
                      >
                        Cancella Dati
                      </button>
                      <button 
                        className="bg-gray-300 text-gray-800 py-2 px-4 rounded hover:bg-gray-400 transition"
                        onClick={() => setShowProgressModal(false)}
                      >
                        Chiudi
                      </button>
                    </div>
                  </div>
                </div>
              )}
            </div>
          );
        };

        // Rendering dell'applicazione
        const domContainer = document.getElementById('root');
        const root = ReactDOM.createRoot(domContainer);
        root.render(<TachistoscopioApp />);
    </script>

    <!-- Service Worker Registration -->
    <script>
      // Codice inline del service worker
      if ('serviceWorker' in navigator) {
        navigator.serviceWorker.register(
          URL.createObjectURL(
            new Blob(
              [`
                const CACHE_NAME = 'tachistoscopio-v1';
                
                self.addEventListener('install', event => {
                  self.skipWaiting();
                });
                
                self.addEventListener('activate', event => {
                  event.waitUntil(self.clients.claim());
                });
                
                self.addEventListener('fetch', event => {
                  event.respondWith(
                    fetch(event.request)
                      .catch(() => {
                        return new Response('Sei offline. Ricarica la pagina quando torni online.');
                      })
                  );
                });
              `],
              { type: 'text/javascript' }
            )
          )
        )
        .then(() => console.log('Service Worker registrato con successo'))
        .catch(error => console.error('Errore registrazione Service Worker:', error));
      }
    </script>
</body>
</html>